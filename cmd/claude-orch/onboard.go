package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/spf13/cobra"
)

func init() {
	onboardCmd := &cobra.Command{
		Use:   "onboard",
		Short: "Set up claude-orch for a new project",
		Long: `Interactive setup wizard for configuring claude-orch with a new project.

This command will:
  - Check prerequisites (git, claude CLI)
  - Create configuration file
  - Set up plans directory structure
  - Create sample plan file
  - Run initial task sync`,
		RunE: runOnboard,
	}
	rootCmd.AddCommand(onboardCmd)
}

var reader = bufio.NewReader(os.Stdin)

func prompt(message, defaultVal string) string {
	if defaultVal != "" {
		fmt.Printf("\033[34m?\033[0m %s [%s]: ", message, defaultVal)
	} else {
		fmt.Printf("\033[34m?\033[0m %s: ", message)
	}

	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)

	if input == "" {
		return defaultVal
	}
	return input
}

func confirm(message string, defaultYes bool) bool {
	var hint string
	if defaultYes {
		hint = "[Y/n]"
	} else {
		hint = "[y/N]"
	}

	fmt.Printf("\033[34m?\033[0m %s %s: ", message, hint)
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(strings.ToLower(input))

	if input == "" {
		return defaultYes
	}
	return input == "y" || input == "yes"
}

func info(msg string)    { fmt.Printf("\033[34m==>\033[0m %s\n", msg) }
func success(msg string) { fmt.Printf("\033[32m==>\033[0m %s\n", msg) }
func warn(msg string)    { fmt.Printf("\033[33m==>\033[0m %s\n", msg) }

func runOnboard(cmd *cobra.Command, args []string) error {
	fmt.Println()
	fmt.Println("  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("  â•‘   Claude Plan Orchestrator Project Onboarding  â•‘")
	fmt.Println("  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Println()

	// Check prerequisites
	fmt.Println("\033[1m\033[36mChecking Prerequisites\033[0m")
	fmt.Println()
	checkPrerequisites()

	// Get project info
	fmt.Println()
	fmt.Println("\033[1m\033[36mProject Configuration\033[0m")
	fmt.Println()

	// Default to current directory if it's a git repo
	defaultRoot := ""
	if _, err := os.Stat(".git"); err == nil {
		defaultRoot, _ = os.Getwd()
	}

	projectRoot := prompt("Project root directory", defaultRoot)
	projectRoot = expandPath(projectRoot)

	if _, err := os.Stat(projectRoot); os.IsNotExist(err) {
		return fmt.Errorf("directory does not exist: %s", projectRoot)
	}

	projectName := prompt("Project name", filepath.Base(projectRoot))
	maxAgentsStr := prompt("Max parallel agents", "3")
	maxAgents, _ := strconv.Atoi(maxAgentsStr)
	if maxAgents <= 0 {
		maxAgents = 3
	}

	home, _ := os.UserHomeDir()
	dataDir := filepath.Join(home, ".claude-orchestrator")
	worktreeDir := prompt("Worktree directory", filepath.Join(dataDir, "worktrees", projectName))
	dbPath := prompt("Database path", filepath.Join(dataDir, projectName+".db"))

	// Notifications
	fmt.Println()
	fmt.Println("\033[1m\033[36mNotifications\033[0m")
	fmt.Println()

	desktopNotify := confirm("Enable desktop notifications?", true)
	slackWebhook := ""
	if confirm("Configure Slack notifications?", false) {
		slackWebhook = prompt("Slack webhook URL", "")
	}

	// Web UI
	fmt.Println()
	fmt.Println("\033[1m\033[36mWeb UI\033[0m")
	fmt.Println()

	webPortStr := prompt("Web UI port", "8080")
	webPort, _ := strconv.Atoi(webPortStr)
	if webPort <= 0 {
		webPort = 8080
	}
	webHost := prompt("Web UI host", "127.0.0.1")

	// Create config
	fmt.Println()
	fmt.Println("\033[1m\033[36mCreating Configuration\033[0m")
	fmt.Println()

	configDir := filepath.Join(home, ".config", "claude-orchestrator")
	configFile := filepath.Join(configDir, "config.toml")

	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("creating config dir: %w", err)
	}
	if err := os.MkdirAll(filepath.Dir(dbPath), 0755); err != nil {
		return fmt.Errorf("creating data dir: %w", err)
	}
	if err := os.MkdirAll(worktreeDir, 0755); err != nil {
		return fmt.Errorf("creating worktree dir: %w", err)
	}

	configContent := fmt.Sprintf(`# Claude Plan Orchestrator Configuration
# Generated by onboard command on %s

[general]
project_root = %q
worktree_dir = %q
max_parallel_agents = %d
database_path = %q

[claude]
model = "claude-opus-4-5-20251101"
max_tokens = 16000

[notifications]
desktop = %t
slack_webhook = %q

[web]
host = %q
port = %d
`, time.Now().Format(time.RFC3339), projectRoot, worktreeDir, maxAgents, dbPath,
		desktopNotify, slackWebhook, webHost, webPort)

	if err := os.WriteFile(configFile, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("writing config: %w", err)
	}
	success("Created config: " + configFile)

	// Create plans directory
	fmt.Println()
	fmt.Println("\033[1m\033[36mSetting Up Plans Directory\033[0m")
	fmt.Println()

	plansDir := filepath.Join(projectRoot, "docs", "plans")
	if _, err := os.Stat(plansDir); os.IsNotExist(err) {
		if confirm("Create plans directory at "+plansDir+"?", true) {
			if err := os.MkdirAll(plansDir, 0755); err != nil {
				return fmt.Errorf("creating plans dir: %w", err)
			}
			success("Created: " + plansDir)
		}
	} else {
		info("Plans directory already exists: " + plansDir)
	}

	// Create sample plan
	if confirm("Create a sample plan file?", true) {
		sampleDir := filepath.Join(plansDir, "sample-module")
		sampleFile := filepath.Join(sampleDir, "epic-00-setup.md")

		if err := os.MkdirAll(sampleDir, 0755); err != nil {
			return fmt.Errorf("creating sample dir: %w", err)
		}

		sampleContent := `---
module: sample
epic: 0
title: Project Setup
priority: high
---

# Epic 00: Project Setup

Initial project scaffolding and configuration.

## Description

This epic covers the basic setup tasks needed before development can begin.

## Acceptance Criteria

- [ ] Development environment configured
- [ ] Dependencies installed
- [ ] CI/CD pipeline set up
- [ ] Documentation structure created

## Tasks

1. Set up development environment
2. Install project dependencies
3. Configure linting and formatting
4. Create initial documentation

## Notes

This is a sample epic file. Modify or replace with your actual project plans.
`
		if err := os.WriteFile(sampleFile, []byte(sampleContent), 0644); err != nil {
			return fmt.Errorf("writing sample plan: %w", err)
		}
		success("Created sample plan: " + sampleFile)
	}

	// Create README in plans
	readmePath := filepath.Join(plansDir, "README.md")
	if _, err := os.Stat(readmePath); os.IsNotExist(err) {
		readmeContent := `# Development Plans

This directory contains implementation plans organized by module.

## Structure

` + "```" + `
plans/
â”œâ”€â”€ {module-name}/
â”‚   â”œâ”€â”€ epic-00-setup.md
â”‚   â”œâ”€â”€ epic-01-core.md
â”‚   â””â”€â”€ ...
â””â”€â”€ README.md
` + "```" + `

## Status Legend

- ğŸ”´ Not started
- ğŸŸ¡ In progress
- ğŸŸ¢ Complete

## Task Format

Each epic file uses YAML frontmatter:

` + "```yaml" + `
---
module: module-name
epic: 1
title: Epic Title
priority: high|normal|low
depends_on:
  - other-module/E00
---
` + "```" + `

## Commands

` + "```bash" + `
# Sync tasks from plans
claude-orch sync

# View status
claude-orch status

# Start tasks
claude-orch start
` + "```" + `
`
		if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
			warn("Could not create README: " + err.Error())
		} else {
			success("Created: " + readmePath)
		}
	}

	// Initial sync
	fmt.Println()
	fmt.Println("\033[1m\033[36mInitial Sync\033[0m")
	fmt.Println()

	if confirm("Run initial task sync?", true) {
		// Call sync directly
		if err := runSync(nil, nil); err != nil {
			warn("Sync failed: " + err.Error())
		} else {
			success("Tasks synced successfully")
		}
	}

	// Summary
	fmt.Println()
	fmt.Println("\033[1m\033[36mSetup Complete!\033[0m")
	fmt.Println()
	fmt.Println("Configuration:")
	fmt.Printf("  Config file:    %s\n", configFile)
	fmt.Printf("  Project root:   %s\n", projectRoot)
	fmt.Printf("  Worktree dir:   %s\n", worktreeDir)
	fmt.Printf("  Database:       %s\n", dbPath)
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Println()
	fmt.Println("  1. Create your implementation plans in:")
	fmt.Printf("     %s/{module}/epic-XX-name.md\n", plansDir)
	fmt.Println()
	fmt.Println("  2. Sync tasks:")
	fmt.Println("     claude-orch sync")
	fmt.Println()
	fmt.Println("  3. Start the orchestrator:")
	fmt.Println("     claude-orch start              # Start ready tasks")
	fmt.Println("     claude-orch tui                # TUI dashboard")
	fmt.Printf("     claude-orch serve              # Web UI at http://%s:%d\n", webHost, webPort)
	fmt.Println()
	fmt.Println("  4. Monitor progress:")
	fmt.Println("     claude-orch status             # Quick summary")
	fmt.Println("     claude-orch list               # All tasks")
	fmt.Println()
	success("Happy orchestrating!")

	return nil
}

func checkPrerequisites() {
	// Check git
	if _, err := os.Stat("/usr/bin/git"); err == nil {
		success("Git: found")
	} else if _, err := os.Stat("/usr/local/bin/git"); err == nil {
		success("Git: found")
	} else {
		warn("Git: not found in standard paths")
	}

	// Check claude
	home, _ := os.UserHomeDir()
	claudePaths := []string{
		"/usr/bin/claude",
		"/usr/local/bin/claude",
		filepath.Join(home, ".local", "bin", "claude"),
		filepath.Join(home, ".claude", "bin", "claude"),
	}
	found := false
	for _, p := range claudePaths {
		if _, err := os.Stat(p); err == nil {
			success("Claude CLI: found at " + p)
			found = true
			break
		}
	}
	if !found {
		warn("Claude CLI: not found (required for agent execution)")
	}
}

func expandPath(path string) string {
	if strings.HasPrefix(path, "~/") {
		home, _ := os.UserHomeDir()
		return filepath.Join(home, path[2:])
	}
	return path
}
